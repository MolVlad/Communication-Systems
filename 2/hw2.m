% Домашнее задание №2. Добавление аддитивного белого гауссовского шума. Расчет MER, BER. 
%> @file hw2.m
% Используемые файлы: mapping.m (написанная вами функция отображения бит на созвездие)
% Шаблоны функций: AWGnoise.m, MERest.m, Nerr.m
% Задание: 
% Данный файл содержит 3 ссылки на функции, которые вы должны прорисать: AWGnoise, MERest, Nerr 
% с инстукциями, что нужно сделать и шаблоном функций с комментериями и местом под ваш код 
% Для сдачи задания необхоимо, чтобы написанные вами функции прощли все 4 проверки.
% =========================================================================
%> Подготовка рабочего места
% =========================================================================
    %> Отчистка workspace
    clear all;
    %> Закрытие рисунков
    close all;
    %> Отчистка Command Window
    clc;
% =========================================================================
%> Задание 1. Наложите аддитивный белый гауссовский шум на сигнал
% =========================================================================
% Напишите функцию, накладывающую на сигнал аддитивный белый гауссовский шум,
% используя генератор нормального распределения normrnd(mu,sigma,[размеры]),
% где mu – матожидание, sigma – стандартное отклонение. Шаблон функции в
% файле AWGnoise.m
% Обратите внимание на то, что сигнал представляется в комплексном виде,
% шум накладывается на I и Q компаненты. Мощность шума, как и мощность
% сигнала определяется суммарной мощностью I и Q компанент. 
% =========================================================================
    bits = randi([0 1], 1, 120000); % генерация бит
    modData = mapping(bits, 2); % QPSK модуляция
    SNR = 5; % Отношение сигнал/шум в дБ
    NoiseData = AWGnoise (modData, SNR, 1); % фунция, которую вы пишите
    scatterplot(NoiseData) % Просмотр результата
% =========================================================================
%> Задание 1. Проверка
% =========================================================================
    %> Используем стандартный объект для расчета MER для проверки
    mer = comm.MER;
    MER = mer(modData.', NoiseData.')
    if abs(MER-SNR)<0.1
        Ans = 'Задание 1 – пройдено'
    else
        Ans = 'Проверте задание 1'
    end
 % ========================================================================
 %> Задание 2. Наложение АБГШ в условии передискретизации
 % ========================================================================
 %> Проверьте работоспособнотсь функции в условии передескретизации
    bits = randi([0 1], 1, 120000); % генерация бит
    modData = sqrt(2)*mapping(bits, 2); % QPSK модуляция
    nSamp = 4;
    % Передескретизация происходит в процессе наложения фильтра корень из
    % приподнятого косинуса
    txfilter = comm.RaisedCosineTransmitFilter('RolloffFactor', 0.2,...
        'FilterSpanInSymbols', 10, 'OutputSamplesPerSymbol', nSamp);
    txSig = txfilter(modData.'); % передескретизация (4 выборки на символ) и фильтрация 
    % Наложение шума 
    SNR = 5; % Отношение сигнал/шум в дБ
    NoiseSig = AWGnoise (txSig.', SNR, nSamp); % фунция, которую вы пишите
    rxfilter = comm.RaisedCosineReceiveFilter('RolloffFactor', 0.2,...
        'FilterSpanInSymbols', 10, 'InputSamplesPerSymbol', nSamp, ...
        'DecimationFactor', nSamp);
    rxSig = rxfilter(NoiseSig.'); % передескретизация (1 выборка на символ) и фильтрация
    scatterplot(rxSig) % Просмотр результата
% =========================================================================
%> Задание 2. Проверка
% =========================================================================
    %> Используем стандартный объект для расчета MER для проверки
    mer = comm.MER;
    %> Убираем кусок, связанный с задержкой фильтра
    rxSig(1:10) = [];
    MER = mer(modData(1:length(rxSig)).', rxSig)
    %MER = mer(modData(11:length(modData)).', rxSig)
    if abs(MER-SNR)<0.1
        Ans = 'Задание 2 – пройдено'
    else
        Ans = 'Проверте задание 2'
    end
% =========================================================================
%> Задание 3. Написать функцию, вычисляющую MER
% =========================================================================
    MERcheck = MERest (modData(1:length(rxSig)), rxSig.')
% =========================================================================
%> Задание 3. Проверка
% =========================================================================
    if abs(MERcheck-MER)<0.00001
        Ans = 'Задание 3 – пройдено'
    else
        Ans = 'Проверте задание 3'
    end
% =========================================================================
%> Задание 4. Написать функцию, вычсляющую колличество ошибок в битовой
% последовательности. Высчитать с ее помощью BER
% =========================================================================
    %> Используем стандартную объект для демодуляции
    demod = comm.QPSKDemodulator;
    checkData = demod(rxSig);
    checkBits = de2bi(checkData, 2);
    checkBits = reshape(checkBits(:,end:-1:1).', 1, []);
    %> Ваша функция расчета числа ошибок
    ERR = Nerr(bits(1:length(checkBits)), checkBits);
    %> Расчет BER
    BER = ERR/length(checkBits)
% =========================================================================
%> Задание 4. Проверка
% =========================================================================
%> Сравниаваем с характерным значением для 5 дБ при QPSK модуляции 
%> (для большей точности нужно больше статистики)
    if abs(BER-0.0375)<0.002
        Ans = 'Задание 4 – пройдено'
    else
        Ans = 'Проверте задание 4'
    end



    
    
    
