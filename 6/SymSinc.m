% Символьная синхронизация 
%> @file SymSinc.m
% =========================================================================
%> @brief Символьная синхронизация
%> @param sign сигнал 4 выборки/символ
%> @return sincsign синхронизированный сигнал
% =========================================================================
function sincsign = SymSinc(sign)
    % =====================================================================
    %> Инициализация
    % =====================================================================
        sincsign = [];
        % Число выборок на символ
        nsamp = 4;
        % Инициализация счетчика по модулю 1
        CNT = 0;
        % Инициализайия начального временного сдвига
        mu = 0; 
        % Интерполяция квадратным полиномом по 4 точкам
        alpha = 0.5;
        InterpCoeff = ...
            [     0,       0,         1,       0;  % Constant
             -alpha, 1+alpha, -(1-alpha), -alpha;  % Linear
              alpha,  -alpha,    -alpha,   alpha]; % Quadratic
         % Флаг момента выборки
         SempFlag = 0;
         % Буфер, где хранятся предидущие выходы интерполятора для расчета
         % TED
         TEDBuff(1:4,1) = 0;
         % Значение, хранимое в интегральной части петлевого фильтра
         part_i = 0;
    % =====================================================================
    %> Расчет коэффицентов петлевого фильтра
    % =====================================================================
        %> Число характеризующее спадание характеристики
        zeta = sqrt(2);
        %> Нормализованная полоса пропускания 
        BnTs = 0.005;
        %> Усиление петлевого фильтра 
        Kp = 2.7;
        %> Обратная связь
        K0 = -1; 
        
        coef = BnTs/(zeta+1/(4*zeta));

        K1 = 4*zeta/nsamp*coef/(1+2*zeta/nsamp*coef+(coef/nsamp)^2);
        K1 = K1 / K0 / Kp;
        
        K2 = 4/(nsamp^2)*(coef^2)/(1+2*zeta/nsamp*coef+(coef/nsamp)^2);
        K2 = K2 / K0 / Kp;
        
   % ======================================================================
   %> Основной цикл
   %=======================================================================
    for i = 4:length(sign)-nsamp
        %> Интерполяция (делаем интерполяцию по 4 точкам, полиномом 2ой степени)
        weigths = [1 mu mu^2] * InterpCoeff;
        IntepolOut = weigths * [sign(i+2); sign(i+1); sign(i); sign(i-1)];
        
        %> Расчитываем ошибку (расчитывается только перед выборкой)
        if SempFlag == 1
            % Гарднер
            e_real = (real(TEDBuff(4)) - real(IntepolOut)) * real(TEDBuff(2));
            e_imag = (imag(TEDBuff(4)) - imag(IntepolOut)) * imag(TEDBuff(2));
            
            e = e_real + e_imag;
            
            % Выборка 
            sincsign = [sincsign; IntepolOut];
        else
            e = 0;
        end
        % Петлевой фильтр part_p пропорцилнальная часть
        % part_p пропорцилнальная часть
        % part_i интегральная часть
        part_p = e * K1;
        part_i = part_i + e * K2;       
        % Выход фильтра
        out = part_p+part_i;
        
        % Счетчик по модулю 1
        step = out + 1/nsamp;
        % todo шаг счетчика
        CNT = CNT-step;
        if CNT<0
            mu = (CNT + step) / step;

            CNT = CNT+1;
            SempFlag = 1;
        else
            SempFlag = 0;
        end
        TEDBuff = [IntepolOut; TEDBuff(1:end-1)];
    end
end 
